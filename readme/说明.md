
### 目录
- [CodeFactExtractor是什么](#CodeFactExtractor是什么)
- [基础](#基础)
    - [OWL](#owl)
    - [事实](#事实)
    - [推理](#推理)
    - [SPARQL查询/更新语言](#SPARQL查询-更新语言)
- [事实抽取](#事实抽取)
    - [访问者](#访问者)
    - [属性处理程序](#属性处理程序)
    - [命名个体](#命名个体)
    - [访问者布局](#访问者)
    - [扩展CodeFactExtractor](#扩展codefactextractor)

CodeFactExtractor是什么
----------
[CodeFactExtractor](https://github.com/Megre/CodeFactExtractor)是一个轻量级框架，可从源代码中提取事实，以进行代码搜索和推理。 [CodeFactExtractor](https://github.com/Megre/CodeFactExtractor)可以通过以下几种方式辅助静态和动态分析：

- 辅助常规的静态分析任务，例如控制流分析，数据流分析和调用图分析。
- 根据自定义规则或编程语言机制搜索代码元素。
- 推断代码元素的关系，例如实现、继承、覆盖和重载。
- 识别设计模式，例如23种经典的GoF（Gang of Four, 四人帮）设计模式和新兴的模式。
- 检测坏味、反模式和缺陷，诸如并行继承层次结构（
Parallel Inheritance Hierarchies）、消息链（Message Chains）、中间人（Middle Man）以及数据类（Data Class)之类的坏味，以及诸如调用父类(Call Super)，循环依赖（Circular Dependency），常量接口（Constant Interface），圆-椭圆问题（Circle-Ellipse Problem）以及对象狂欢（Object Orgy）之类的反模式。
- 封装时序信息以推理运行时行为，例如方法的调用顺序以及数据传输（例如，通过监视字段修改）。

基础
----------
### OWL
W3C <a href="https://www.w3.org/2001/sw/wiki/OWL"> Web本体语言（Web Ontology Language, OWL）</a>是一种语义Web语言，旨在表示丰富而复杂的事物知识、事物分组以及事物之间的关系。

在OWL中，`类（class）`代表一组元素。 一个类的实例称为属于该类的`个体（individual）`。 `对象属性（object property）`表示个体之间的关系。 `数据类型属性（data type property）`将个体与数据类型值相关联。 子类（subclass）关系定义类的层次结构，子属性（subproperty）关系定义属性的层次结构。

“.owl” 文件是文本文件，通常以 RDF/XML 语法保存。

### 事实

知识通常表示为三元组形式的事实。三元组的形式为：

(Subject *predicate* Object)

即：

(主语 *谓语* 宾语)

##### 示例1

    (exam:Lily exam:fatherIs exam:Johnson)
    (exam:Lily rdf:type exam:Person)
    (exam:Lily exam:ageIs 10)
    (exam:Lily exam:hasBrother exam:Tom)

Lily、Johnson 和 Tom 都是类型（*`rdf:type`*）为 Person 的个体。

属性 *`exam:fatherIs`*、 *`rdf:type`*、 *`exam:ageIs`* 和 *`exam:hasBrother`* 将个体链接到其他个体或字面量。*`exam:fatherIs`*、 *`exam:hasBrother`* 和 *`rdf:type`* 都是对象属性，而 *`exam:ageIs`* 是数据类型属性。

前缀 “rdf” 是 XML 命名空间，定义为 <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#" target="_blank">http://www.w3.org/1999/02/22-rdf-syntax-ns#</a>，其中定义了属性 *`rdf:type`*。

另一个用户定义的命名空间 “exam” 被定义为 [http://www.spart.group/exam#](https://github.com/Megre/CodeFactExtractor/blob/master/readme/exam.owl)，其中定义了本体类 *`exam:PersonIs`* 以及属性 *`exam:fatherIs`*、 *`exam:ageIs`* 和 *`exam:hasBrother`*。

可以将 [示例1](#示例1) 中的事实以 RDF/XML 格式保存为以下 [exam.owl](https://github.com/Megre/CodeFactExtractor/blob/master/readme/exam.owl) 文件:

    <?xml version="1.0"?>
    <rdf:RDF xmlns="http://www.spart.group/exam#"
        xml:base="http://www.spart.group/exam"
        xmlns:owl="http://www.w3.org/2002/07/owl#"
        xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
        xmlns:xml="http://www.w3.org/XML/1998/namespace"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
        xmlns:exam="http://www.spart.group/exam#"
        xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#">
        
        <owl:Ontology rdf:about="http://www.spart.group/exam"/>
    
        <owl:ObjectProperty rdf:about="http://www.spart.group/exam#hasBrother"/>
        <owl:ObjectProperty rdf:about="http://www.spart.group/exam#fatherIs"/>
        <owl:ObjectProperty rdf:about="http://www.spart.group/exam#hasSister"/>
        <owl:DatatypeProperty rdf:about="http://www.spart.group/exam#ageIs"/>
        
        <owl:Class rdf:about="http://www.spart.group/exam#Person"/>
    
        <owl:NamedIndividual rdf:about="http://www.spart.group/exam#Johnson">
            <rdf:type rdf:resource="http://www.spart.group/exam#Person"/>
        </owl:NamedIndividual>
    
        <owl:NamedIndividual rdf:about="http://www.spart.group/exam#Lily">
            <rdf:type rdf:resource="http://www.spart.group/exam#Person"/>
            <hasBrother rdf:resource="http://www.spart.group/exam#Tom"/>
            <fatherIs rdf:resource="http://www.spart.group/exam#Johnson"/>
            <ageIs rdf:datatype="http://www.w3.org/2001/XMLSchema#integer">10</age>
        </owl:NamedIndividual>
        
        <owl:NamedIndividual rdf:about="http://www.spart.group/exam#Tom">
            <rdf:type rdf:resource="http://www.spart.group/exam#Person"/>
        </owl:NamedIndividual>
        
    </rdf:RDF>

为了对概念（如本体类）和关系（如属性）进行建模，建议使用 [Protege](https://protege.stanford.edu) 工具创建所示 [exam.owl](https://github.com/Megre/CodeFactExtractor/blob/master/readme/exam.owl) ，而不要通过编辑文本创建。基于OWL模型，[CodeFactExtractor](https://github.com/Megre/CodeFactExtractor) 辅助从源代码中抽取事实。

### 推理

根据 [示例1](#示例1) 中的事实，可以推断出以下事实：

    (exam:Tom exam:fatherIs exam:Johnson)
    (exam:Tom exam:hasSister exam:Lily)

推理可以表示为：

    (exam:Tom exam:fatherIs exam:Johnson), (exam:Tom exam:hasSister exam:Lily) ← (exam:Lily exam:fatherIs exam:Johnson), (exam:Lily exam:hasBrother exam:Tom)

给定一个人 Lucy，以下事实：

    (exam:Lucy exam:teacherIs exam:Lily)

无法确定是否能通过 [示例1](#示例1) 中的事实来推断。这种推断策略称为`开放世界假设（Open World Assumption， OWA）`。在另一种策略，即`封闭世界假设（Closed World Assumption，CWA）`中，如果不确定断言是否为真，则推断出它的否定。因此，推断出“Lucy 不是 Lily 的老师”。OWA通常更为合理，因为其他事实可能在别处。

但是 [CodeFactExtractor](https://github.com/Megre/CodeFactExtractor) 的策略以用户自定义的方式工作。例如，如果在提取过程中对于每个类/接口的每个公共方法，都声明了如下事实：

    (any-public-method exam:hasModifier "public")

则可以放心地断定，未通过 *`exam：hasModifier`* 链接到 “public” 的方法是非 “public” 方法。 (在 Java 中，即使接口中的方法未声明为 public，其访问权限也是 public。这样的方法也被视为非 “public”，因为 *`exam:hasModifier`* 指代在源代码中声明的修饰符。)

根据 [示例1](#示例1) 中的事实，还可以推断出其他事实，例如“Johnson至少有两个孩子”，“Johnson有一个儿子 Tom”和“Tom比Johnson年轻”，这些事实是根据常识推断的。在 [CodeFactExtractor](https://github.com/Megre/CodeFactExtractor) 中，推断通常根据编程语言的编程机制进行。例如，如果一个类的两个方法名称相同但签名不同，则可以推断这两个方法具有重载关系。可以创建一个属性 (例如 *`exam：overloads`* ) 来表示该关系。

一个重要的推理策略是重用现有关系来建立更抽象的关系。除 [示例1](#示例1) 之外，给出以下事实：

    (exam:Johnson exam:fatherIs exam:George)
    (exam:Tom exam:ageIs 12)
    
则可以推断出以下事实：
    
    (exam:Lily exam:anElderIs exam:Tom)
    (exam:Tom exam:anElderIs exam:Johnson)
    (exam:Tom exam:anElderIs exam:George)
    ...
    
属性 *`exam:anElderIs`*比属性 *`exam:fatherIs`* 更一般化，因为父亲永远是儿子或女儿的长者；相反，长辈关系不仅表示 “儿子-父亲” / “女儿-父亲” 关系，还可能表示 “妹妹-哥哥” 关系或 “孙子-祖父” 关系。以下规则可用于表达长辈关系：

    (?x exam:anElderIs ?z) ← (?x exam:anElderIs ?y), (?y exam:anElderIs ?z)
    
这意味着 *`exam：anElderIs`* 是传递属性。

这种推断策略称为 “一般化”，它通过组合现有属性或对现有属性施加限制来提高抽象级别。基于对每个属性含义的明确定义，如何推理以及推理内容取决于实际需求。

未完待续...

